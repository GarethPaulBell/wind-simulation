[
  {
    "objectID": "define_boundary_conditions.html",
    "href": "define_boundary_conditions.html",
    "title": "Generate a blank domain",
    "section": "",
    "text": "### Boundary Labels: - The boundaries of the simulation box are denoted as follows: - N: North - S: South - E: East - W: West - T: Top - B: Bottom\n\nVoxel Space Orientation:\n\nz-axis: Represents the first dimension of the voxel space.\ny-axis: Represents the second dimension, with the 0th position being north.\nx-axis: Represents the third dimension, with the 0th position being to the west.\n\n\n\nWind Direction and Boundary Conditions:\nThe simulation accounts for wind blowing horizontally at specific compass bearings, leading to 8 distinct cases for setting boundary conditions:\n\nCases 0 to 3 (Cardinal Directions): Wind at 0° (N), 90° (E), 180° (S), 270° (W). One boundary in either the xz or yz plane will have a specified velocity, either positive or negative, corresponding to the wind direction.\nCases 4 to 7 (Inter-Cardinal Directions):\n\nNE quadrant: Positive y-velocity (vy), Negative x-velocity (vx)\nSE quadrant: Negative y-velocity (vy), Negative x-velocity (vx)\nSW quadrant: Negative y-velocity (vy), Positive x-velocity (vx)\nNW quadrant: Positive y-velocity (vy), Positive x-velocity (vx)\n\n\n\n\nCross Section and Land Boundaries:\n\nThe landscape is represented within the voxel space, dividing the box’s cross-section into areas of land and clear air.\nThe interaction between the wind and the landscape introduces variations in boundary conditions across different parts of the box.\n\n\n\nQuestion on Boundary Conditions:\n\nNon-slip Conditions for Land Voxels: Can all land voxels be treated as non-slip conditions to simulate the interaction with the wind accurately?\n\n\n\nProposed Boundary Condition Implementation:\n\nWind Incident Borders: For borders facing the direction of the incoming wind, apply constant velocity boundaries to simulate the wind entering the simulation space.\nDo Nothing for the Ceiling: The top boundary (ceiling) of the simulation box does not directly influence the wind simulation and may be treated as a ‘do nothing’ condition.\nRemaining Borders and Air Spaces: For parts of the box not defined as land or directly affected by the incoming wind, apply ‘Do Not Care’ or appropriate boundary conditions to simulate the natural behavior of air flow around and over the landscape.\n\n\nimport numpy as np\nimport os\nimport sys\n\n\n# Assuming 'src' is in a directory at the same level as the current script's directory\n# Adjust the path below according to your directory structure\nxlb = \"/mnt/c/Users/GGPC/Documents/GitHub/XLB\"\n__file__ = os.getcwd()\npath_to_src = os.path.join(os.path.dirname(__file__), xlb)\nsys.path.append(path_to_src)\n\n\nimport matplotlib.pylab as plt\nfrom src.models import BGKSim, KBCSim\nfrom src.lattice import LatticeD3Q19, LatticeD3Q27\nfrom src.boundary_conditions import *\nimport numpy as np\nfrom src.utils import *\nfrom jax import config\nimport os\n#os.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=8'\nimport jax\nimport scipy\n\n\nclass Auckland_Harbour(KBCSim):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        #TODO\n        # Test the following boundary conditions one at a time\n\"\"\"\n    def set_boundary_conditions(self):\n        # Load the voxelised land and set to bounce back\n        land_voxels = np.load(\"Akl_Voxel_Matrix.npy\")\n        land_indicies = np.argwhere(land_voxels)\n    \n        # Wall boundary conditions\n        free_conditions = np.concatenate((self.boundingBoxIndices['bottom'], self.boundingBoxIndices['top'], self.boundingBoxIndices['front'], self.boundingBoxIndices['back'], self.boundingBoxIndices['right']))\n        self.BCs.append(DoNothing(tuple(free_conditions.T), self.gridInfo, self.precisionPolicy))\n    \n        # Inlet boundary conditions\n        inlet = self.boundingBoxIndices['left']\n    \n        # Convert inlet and land_indicies to sets of tuples for easy comparison\n        inlet_set = set(map(tuple, inlet))\n        land_indicies_set = set(map(tuple, land_indicies))\n    \n        # Find inlet voxels that are not land by set difference\n        inlet_not_land = np.array(list(inlet_set - land_indicies_set))\n    \n        if inlet_not_land.size &gt; 0:\n            # Adjust the shape of inlet_not_land if necessary, depending on your simulation requirements\n            # Apply conditions to the filtered inlet voxels\n            rho_inlet = np.ones((inlet_not_land.shape[0], 1), dtype=self.precisionPolicy.compute_dtype)\n            # Assuming the inlet velocity needs to be specified per voxel, adjust as necessary\n            vel_inlet = np.zeros((inlet_not_land.shape[0], 3), dtype=self.precisionPolicy.compute_dtype)  # Assuming 3D velocity vectors\n            # You would then need to apply these conditions appropriately within your simulation framework\n            \"\"\"\n\n'\\n    def set_boundary_conditions(self):\\n        # Load the voxelised land and set to bounce back\\n        land_voxels = np.load(\"Akl_Voxel_Matrix.npy\")\\n        land_indicies = np.argwhere(land_voxels)\\n    \\n        # Wall boundary conditions\\n        free_conditions = np.concatenate((self.boundingBoxIndices[\\'bottom\\'], self.boundingBoxIndices[\\'top\\'], self.boundingBoxIndices[\\'front\\'], self.boundingBoxIndices[\\'back\\'], self.boundingBoxIndices[\\'right\\']))\\n        self.BCs.append(DoNothing(tuple(free_conditions.T), self.gridInfo, self.precisionPolicy))\\n    \\n        # Inlet boundary conditions\\n        inlet = self.boundingBoxIndices[\\'left\\']\\n    \\n        # Convert inlet and land_indicies to sets of tuples for easy comparison\\n        inlet_set = set(map(tuple, inlet))\\n        land_indicies_set = set(map(tuple, land_indicies))\\n    \\n        # Find inlet voxels that are not land by set difference\\n        inlet_not_land = np.array(list(inlet_set - land_indicies_set))\\n    \\n        if inlet_not_land.size &gt; 0:\\n            # Adjust the shape of inlet_not_land if necessary, depending on your simulation requirements\\n            # Apply conditions to the filtered inlet voxels\\n            rho_inlet = np.ones((inlet_not_land.shape[0], 1), dtype=self.precisionPolicy.compute_dtype)\\n            # Assuming the inlet velocity needs to be specified per voxel, adjust as necessary\\n            vel_inlet = np.zeros((inlet_not_land.shape[0], 3), dtype=self.precisionPolicy.compute_dtype)  # Assuming 3D velocity vectors\\n            # You would then need to apply these conditions appropriately within your simulation framework\\n            '\n\n\n\nprecision = 'f32/f32'\nlattice = LatticeD3Q27(precision)\nnx = 601\nny = 351\nnz = 251\n\nRe = 50000.0\nprescribed_vel = 0.05\nclength = nx - 1\n\nvisc = prescribed_vel * clength / Re\nomega = 1.0 / (3. * visc + 0.5)\n\nos.system('rm -rf ./*.vtk && rm -rf ./*.png')\n\nkwargs = {\n        'lattice': lattice,\n        'omega': omega,\n        'nx': nx,\n        'ny': ny,\n        'nz': nz,\n        'precision': precision,\n        'io_rate': 100,\n        'print_info_rate': 100,\n        'return_fpost': True  # Need to retain fpost-collision for computation of lift and drag\n    }\nsim = Auckland_Harbour(**kwargs)\n    #sim.run(200000)\n\n**** Simulation Parameters for Auckland_Harbour ****\n            Parameter | Value\n--------------------------------------------------\n                Omega | 1.9928258270227182\n     Grid Points in X | 601\n     Grid Points in Y | 351\n     Grid Points in Z | 251\n       Dimensionality | 3\n     Precision Policy | f32/f32\n         Lattice Type | D3Q27\n      Checkpoint Rate | 0\n Checkpoint Directory | ./checkpoints\n  Downsampling Factor | 1\n      Print Info Rate | 100\n             I/O Rate | 100\n        Compute MLUPS | False\n   Restore Checkpoint | False\n              Backend | gpu\n    Number of Devices | 1\nTime to create the grid mask: 0.09856700897216797\nTime to create the local masks and normal arrays: 1.1920928955078125e-06\n\n\n\n# Start measuring time for the voxelization process.\ntime_start = time()\n\n# Determine the length of the car in lattice Boltzmann method (LBM) units. This script assumes the car length is one-fourth the size of the domain in the x-direction.\n#NB Here we will just need to take our voxelised data and assign nx,ny and nz values?\ncar_length_lbm_unit = self.nx / 4\n\n# Voxelizing the STL file. The `voxelize_stl` function converts the STL file into a voxel representation where the size of the voxel grid is determined by the car length in LBM units. It returns the voxelized object and the pitch (size of each voxel).\n# is pitch used? \ncar_voxelized, pitch = voxelize_stl(stl_filename, car_length_lbm_unit)\n\n# Access the matrix representing the voxelized car. This matrix contains boolean values indicating whether a voxel is part of the car (True) or not (False).\n#NB Adust the previous code to have boolean values, not integers\ncar_matrix = car_voxelized.matrix\n\n# Print the time taken to voxelized the car and the pitch (voxel size) used.\nprint('Voxelization time for pitch={}: {} seconds'.format(pitch, time() - time_start))\nprint(\"Car matrix shape: \", car_matrix.shape)\n\n# Calculate the area (in terms of voxels) occupied by the car by multiplying the dimensions of the car matrix, excluding the length dimension.\n# NB this is actually the volume! \nself.car_area = np.prod(car_matrix.shape[1:])\n\n# Calculate the amount of shift needed to place the car correctly within the simulation domain. This involves calculating the difference between the domain size and the car matrix size and then adjusting the position accordingly.\n# OK - we don't need to do this\ntx, ty, tz = np.array([nx, ny, nz]) - car_matrix.shape\nshift = [tx//4, ty//2, 0]\n\n# Find the indices of voxels that are part of the car and apply the shift to position the car within the simulation domain.\n# NB modify this so that we are using our voxelised land\ncar_indices = np.argwhere(car_matrix) + shift\n\n# Add a bounce-back boundary condition for the car's surface. This condition simulates a solid, immovable object within the fluid flow.\n# NB ditto, we should just add the modified value calculated earlier\nself.BCs.append(BounceBackHalfway(tuple(car_indices.T), self.gridInfo, self.precisionPolicy))\n\n# Concatenate the indices of the bounding box's walls (bottom, top, front, back) to create a solid boundary around the simulation domain.\n# NB This should be similar, but in this case the self bounding box where there is no wind indcident should be doNothing conditions\nwall = np.concatenate((self.boundingBoxIndices['bottom'], self.boundingBoxIndices['top'], self.boundingBoxIndices['front'], self.boundingBoxIndices['back']))\n\n# Add a bounce-back boundary condition for these walls, treating them as solid, immovable barriers.\n# NB not present in this case\nself.BCs.append(BounceBack(tuple(wall.T), self.gridInfo, self.precisionPolicy))\n\n# Define a \"do nothing\" boundary condition for the right boundary, typically used to simulate an open or outflow boundary.\ndoNothing = self.boundingBoxIndices['right']\nself.BCs.append(DoNothing(tuple(doNothing.T), self.gridInfo, self.precisionPolicy))\nself.BCs[-1].implementationStep = 'PostCollision'\n# The commented-out code below would set up a Zou/He pressure boundary condition on the right boundary, but it's not used in this snippet.\n\n# Set up an inlet boundary condition on the left boundary with a prescribed velocity. This simulates fluid entering the simulation domain.\ninlet = self.boundingBoxIndices['left']\nrho_inlet = np.ones((inlet.shape[0], 1), dtype=self.precisionPolicy.compute_dtype) # Density at the inlet.\nvel_inlet = np.zeros(inlet.shape, dtype=self.precisionPolicy.compute_dtype) # Velocity at the inlet, initialized to zero.\n\n# Prescribe the velocity in the x-direction for the inlet boundary condition.\nvel_inlet[:, 0] = prescribed_vel\nself.BCs.append(EquilibriumBC(tuple(inlet.T), self.gridInfo, self.precisionPolicy, rho_inlet, vel_inlet))",
    "crumbs": [
      "Generate a blank domain"
    ]
  },
  {
    "objectID": "condition_data.html",
    "href": "condition_data.html",
    "title": "Load and display downloaded point cloud",
    "section": "",
    "text": "import rasterio\nfrom rasterio.merge import merge\nfrom rasterio.plot import show\nimport glob\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom os import path\nimport os\n\n\nroot_path = os.getenv('WIN_GITHUB')\n\n\n\n\n'/mnt/c/Users/GGPC/Documents/GitHub/wind-simulation/nbs'\n\n\n\nprint(root_path)\n\n/mnt/c/Users/GGPC/Documents/GitHub/\n\n\n\nc_path_north = os.path.join(*[root_path,'wind-simulation/data/raw/','lds-auckland-north-lidar-1m-dem-2016-2018-GTiff'])\nc_path_south = os.path.join(*[root_path,'wind-simulation/data/raw/','lds-auckland-south-lidar-1m-dsm-2016-2017-GTiff'])\n#ds-auckland-south-lidar-1m-dsm-2016-2017-GTiff\n\n\nprint(c_path_north)\n\n/mnt/c/Users/GGPC/Documents/GitHub/wind-simulation/data/raw/lds-auckland-north-lidar-1m-dem-2016-2018-GTiff\n\n\n\nraster_files = glob.glob(f\"{c_path_north}/*.tif\") + glob.glob(f\"{c_path_south}/*.tif\")\n\n\nrasters = []\n\n\n# Open the rasters\nfor file in raster_files:\n    src = rasterio.open(file)\n    rasters.append(src)\n\n\n# Merge rasters\nmosaic, out_trans = merge(rasters)\n\n\nmosaic[0,20,20]\n\n-9999.0\n\n\n\n#Set the no-data value (replace with the actual no-data value for your data)\nno_data_value = -9999\n\n# Mask the no-data values\nmosaic_masked = np.ma.masked_where(mosaic[0] == no_data_value, mosaic[0])\n\n# Choose a colormap\ncmap = plt.cm.BrBG\n# Set the 'bad' data (masked data) color to 'white' or any other color\ncmap.set_bad(color='white')\n\n# Plot the masked array with the colormap\nplt.figure(figsize=(10, 10))\nplt.imshow(mosaic_masked, cmap=cmap)\n\n# Optionally, set the color range to the 2nd and 98th percentiles to enhance contrast\nvmin, vmax = np.percentile(mosaic_masked.compressed(), (2, 98))\nplt.imshow(mosaic_masked, cmap=cmap, vmin=vmin, vmax=vmax)\n\n/tmp/ipykernel_3518/1990142664.py:10: MatplotlibDeprecationWarning: You are modifying the state of a globally registered colormap. This has been deprecated since 3.3 and in 3.6, you will not be able to modify a registered colormap in-place. To remove this warning, you can make a copy of the colormap first. cmap = mpl.cm.get_cmap(\"BrBG\").copy()\n  cmap.set_bad(color='white')\n\n\n\n\n\n\n\n\n\n\nmax_height = mosaic_masked.data.max()\n\n\ndata_surface = mosaic_masked.data[0:8000,0:-1]\n\n\ndata_surface[data_surface &lt;0 ] = 0\n\n\nplt.figure(figsize=(10, 10))\nplt.imshow(data_surface,cmap=cmap)\n\n\n\n\n\n\n\n\n\ndelta_x, delta_y = 10, 10\n\n\nstride = 5\n\n\n# Pad the 'data_surface' array to the right with 2000 columns of zeros\nextended_data_surface = np.pad(data_surface, ((0, 0), (0, 2000)), 'constant', constant_values=0)[::stride,::stride]\nprint(extended_data_surface)\n\n[[0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n ...\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]]\n\n\n\nplt.imshow(extended_data_surface,cmap=cmap)\n\n\n\n\n\n\n\n\n\nmatrix_size = (extended_data_surface.shape[0]*extended_data_surface.shape[1]*200/1e6)*8\n\n\nprint(f'Matrix Size {matrix_size} MB')\n\nMatrix Size 9630.72 MB\n\n\n\nz_max = int(np.round(max_height,-2)); print(z_max)\n\n200\n\n\n\ndef height_matrix_to_voxel_matrix(height_matrix, headroom, stride):\n    # Get the dimensions of the 2D height matrix\n    \n    strided_matrix = height_matrix[::stride,::stride]\n    rows, cols = strided_matrix.shape\n    \n    # Determine the maximum height to set the depth of the 3D voxel matrix\n    max_height = int(np.max(height_matrix)) + int(headroom)\n    print(max_height)\n    \n    # Create a 3D voxel matrix initialized to 0 (no voxel)\n    # The shape is (height, rows, cols) to represent (z, y, x) coordinates\n    voxel_matrix = np.zeros((max_height, rows, cols), dtype=np.int8)\n    \n    # Fill the voxel matrix based on the heights specified in the height_matrix\n    for x in range(rows):\n        for y in range(cols):\n            height = int(strided_matrix[x, y]/stride)\n            voxel_matrix[:height, x, y] = 1  # Fill column with voxels up to the specified height\n    return voxel_matrix\n\n\nvoxel_matrix = height_matrix_to_voxel_matrix(extended_data_surface,0,stride)\n\n170\n\n\n\nplt.imshow(np.sum(voxel_matrix,0))\n\n\n\n\n\n\n\n\n\nfrom vedo import *\nsettings.default_backend='vtk'\n\n\nvoxel_matrix_ = voxel_matrix.astype(np.uint8)\n\n\nvolume = Volume(voxel_matrix_)\n\n\nplotter = Plotter()\n\n\nplotter.add(volume)\n\n&lt;vedo.plotter.Plotter&gt;\n\n\n\nshow(volume)\n\n\nDetermine boundary conditions\n\nBoundary Labels:\n\nThe boundaries of the simulation box are denoted as follows:\n\nN: North\nS: South\nE: East\nW: West\nT: Top\nB: Bottom\n\n\n\n\nVoxel Space Orientation:\n\nz-axis: Represents the first dimension of the voxel space.\ny-axis: Represents the second dimension, with the 0th position being north.\nx-axis: Represents the third dimension, with the 0th position being to the west.\n\n\n\nWind Direction and Boundary Conditions:\nThe simulation accounts for wind blowing horizontally at specific compass bearings, leading to 8 distinct cases for setting boundary conditions:\n\nCases 0 to 3 (Cardinal Directions): Wind at 0° (N), 90° (E), 180° (S), 270° (W). One boundary in either the xz or yz plane will have a specified velocity, either positive or negative, corresponding to the wind direction.\nCases 4 to 7 (Inter-Cardinal Directions):\n\nNE quadrant: Positive y-velocity (vy), Negative x-velocity (vx)\nSE quadrant: Negative y-velocity (vy), Negative x-velocity (vx)\nSW quadrant: Negative y-velocity (vy), Positive x-velocity (vx)\nNW quadrant: Positive y-velocity (vy), Positive x-velocity (vx)\n\n\n\n\nCross Section and Land Boundaries:\n\nThe landscape is represented within the voxel space, dividing the box’s cross-section into areas of land and clear air.\nThe interaction between the wind and the landscape introduces variations in boundary conditions across different parts of the box.\n\n\n\nQuestion on Boundary Conditions:\n\nNon-slip Conditions for Land Voxels: Can all land voxels be treated as non-slip conditions to simulate the interaction with the wind accurately?\n\n\n\nProposed Boundary Condition Implementation:\n\nWind Incident Borders: For borders facing the direction of the incoming wind, apply constant velocity boundaries to simulate the wind entering the simulation space.\nDo Nothing for the Ceiling: The top boundary (ceiling) of the simulation box does not directly influence the wind simulation and may be treated as a ‘do nothing’ condition.\nRemaining Borders and Air Spaces: For parts of the box not defined as land or directly affected by the incoming wind, apply ‘Do Not Care’ or appropriate boundary conditions to simulate the natural behavior of air flow around and over the landscape.\n\n\ndef determine_inlet_outlet(wind_direction):\n    \"\"\"\n    Determine the inlet and outlet sides of the box based on wind direction.\n    \n    Parameters:\n    - wind_direction: int or float representing the compass bearing of the wind.\n    \n    Returns:\n    - Tuple of (inlet, outlet) where each is a string representing the sides of the box.\n    \"\"\"\n    if wind_direction == 0:\n        return ('N', 'S')\n    elif wind_direction == 90:\n        return ('E', 'W')\n    elif wind_direction == 180:\n        return ('S', 'N')\n    elif wind_direction == 270:\n        return ('W', 'E')\n    elif 0 &lt; wind_direction &lt; 90:\n        return ('NE', 'SW')\n    elif 90 &lt; wind_direction &lt; 180:\n        return ('SE', 'NW')\n    elif 180 &lt; wind_direction &lt; 270:\n        return ('SW', 'NE')\n    elif 270 &lt; wind_direction &lt; 360:\n        return ('NW', 'SE')\n    else:\n        raise ValueError(\"Invalid wind direction. Should be between 0 and 360 degrees.\")\n\n\ntest_directions = [0, 90, 180, 270, 45, 135, 225, 315]\n\nfor direction in test_directions:\n    inlet, outlet = determine_inlet_outlet(direction)\n    print(f\"Wind Direction: {direction} degrees -&gt; Inlet: {inlet}, Outlet: {outlet}\")\n\n\ndef determine_axis(wind_direction):\n    \"\"\"\n    Determine the axis affected by the wind direction for cardinal directions.\n    \n    Parameters:\n    - wind_direction: The wind direction in degrees (0, 90, 180, 270).\n    \n    Returns:\n    - int: 0 for the x-axis, 1 for the y-axis.\n    \"\"\"\n    if wind_direction in [0, 180]:\n        return 0  # Wind affects the x-axis\n    elif wind_direction in [90, 270]:\n        return 1  # Wind affects the y-axis\n    else:\n        raise ValueError(\"Invalid wind direction. Expected one of: 0, 90, 180, 270.\")\n\n# Testing the function\ntest_directions = [0, 90, 180, 270]\n\nfor direction in test_directions:\n    print(f\"Wind direction: {direction} degrees -&gt; Axis affected: {determine_axis(direction)}\")\n\n\nimport numpy as np\n\ndef calculate_velocity_components(wind_direction, wind_velocity):\n    \"\"\"\n    Calculate the velocity components for wind coming from any angle.\n    \n    Parameters:\n    - wind_direction: The wind direction in degrees from the North (0 degrees).\n    - wind_velocity: The magnitude of the wind velocity.\n    \n    Returns:\n    - A tuple (vx, vy) representing the velocity components in the x (East) and y (North) directions.\n    \"\"\"\n    # Convert wind direction from degrees to radians\n    wind_direction_radians = np.radians(wind_direction)\n    \n    # Calculate velocity components\n    # Note: Wind direction is measured from the North, so adjustments are made accordingly\n    vx = wind_velocity * np.sin(wind_direction_radians)  # Eastward component\n    vy = wind_velocity * np.cos(wind_direction_radians)  # Northward component\n    \n    return (vx, vy)\n\n# Testing the function with different wind directions\ntest_directions = [0, 45, 90, 135, 180, 225, 270, 315]\nwind_velocity = 10  # Example wind velocity magnitude\n\nfor direction in test_directions:\n    vx, vy = calculate_velocity_components(direction, wind_velocity)\n    print(f\"Wind direction: {direction} degrees -&gt; Velocity components: vx={vx:.2f}, vy={vy:.2f}\")\n\n\nimport numpy as np\n\ndef set_wind_boundary_conditions(land_voxel_mesh, wind_direction, wind_velocity, gridInfo, precisionPolicy):\n    \"\"\"\n    Set boundary conditions for simulation with wind over land.\n    \n    Parameters:\n    - land_voxel_mesh: 3D numpy array representing land as True (land) and False (air).\n    - wind_direction: Compass bearing of the wind (0, 90, 180, 270, or quadrant).\n    - wind_velocity: Magnitude of the wind velocity.\n    - gridInfo: Information about the simulation grid.\n    - precisionPolicy: Policy determining the numerical precision of computations.\n    \"\"\"\n    print(\"Setting boundary conditions based on wind direction and land presence...\")\n    \n    # Initialize boundary conditions list\n    BCs = []\n\n    # Determine inlet and outlet based on wind_direction\n    inlet, outlet = determine_inlet_outlet(wind_direction)\n    \n    # Set non-slip boundary conditions for land voxels\n    land_indices = np.argwhere(land_voxel_mesh)\n    BCs.append(BounceBackHalfway(tuple(land_indices.T), gridInfo, precisionPolicy))\n    \n    # Set inlet boundary condition with wind velocity\n    vel_inlet = np.zeros((len(inlet), 3), dtype=precisionPolicy.compute_dtype)\n    if wind_direction in [0, 90, 180, 270]:  # Cardinal directions\n        vel_inlet[:, determine_axis(wind_direction)] = wind_velocity\n    else:  # Quadrant directions\n        vel_inlet[:, 0], vel_inlet[:, 1] = calculate_quadrant_velocity(wind_direction, wind_velocity)\n    BCs.append(EquilibriumBC(tuple(inlet.T), gridInfo, precisionPolicy, np.ones(len(inlet)), vel_inlet))\n    \n    # Apply do nothing condition for the ceiling and other non-land boundaries\n    # Additional logic to identify and apply these conditions based on `land_voxel_mesh` and `wind_direction`\n    \n    return BCs",
    "crumbs": [
      "Load and display downloaded point cloud"
    ]
  },
  {
    "objectID": "01_car_example.html",
    "href": "01_car_example.html",
    "title": "wind-simulation",
    "section": "",
    "text": "import numpy as np\n# from IPython import display\nimport sys\nsys.path.append(\"/home/gareth/XLB\")\nimport matplotlib.pylab as plt\nfrom src.models import BGKSim, KBCSim\nfrom src.lattice import LatticeD3Q19, LatticeD3Q27\nfrom src.boundary_conditions import *\nimport numpy as np\nfrom src.utils import *\nfrom jax import config\nimport os\n#os.environ[\"XLA_FLAGS\"] = '--xla_force_host_platform_device_count=8'\nimport jax\nimport scipy\n\n\n\n\n\nXLB/          color_testing/  readme.txt   taskwarrior_data/\n__pycache__/  gareth/         taskd_data/\n\n\n\nclass Car(KBCSim):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def voxelize_stl(self, stl_filename, length_lbm_unit):\n        mesh = trimesh.load_mesh(stl_filename, process=False)\n        length_phys_unit = mesh.extents.max()\n        pitch = length_phys_unit/length_lbm_unit\n        mesh_voxelized = mesh.voxelized(pitch=pitch)\n        mesh_matrix = mesh_voxelized.matrix\n        return mesh_matrix, pitch\n\n    def set_boundary_conditions(self):\n        print('Voxelizing mesh...')\n        time_start = time()\n        stl_filename = 'stl-files/DrivAer-Notchback.stl'\n        car_length_lbm_unit = self.nx / 4\n        car_voxelized, pitch = voxelize_stl(stl_filename, car_length_lbm_unit)\n        car_matrix = car_voxelized.matrix\n        print('Voxelization time for pitch={}: {} seconds'.format(pitch, time() - time_start))\n        print(\"Car matrix shape: \", car_matrix.shape)\n\n        self.car_area = np.prod(car_matrix.shape[1:])\n        tx, ty, tz = np.array([nx, ny, nz]) - car_matrix.shape\n        shift = [tx//4, ty//2, 0]\n        car_indices = np.argwhere(car_matrix) + shift\n        self.BCs.append(BounceBackHalfway(tuple(car_indices.T), self.gridInfo, self.precisionPolicy))\n\n        wall = np.concatenate((self.boundingBoxIndices['bottom'], self.boundingBoxIndices['top'],\n                               self.boundingBoxIndices['front'], self.boundingBoxIndices['back']))\n        self.BCs.append(BounceBack(tuple(wall.T), self.gridInfo, self.precisionPolicy))\n\n        doNothing = self.boundingBoxIndices['right']\n        self.BCs.append(DoNothing(tuple(doNothing.T), self.gridInfo, self.precisionPolicy))\n        self.BCs[-1].implementationStep = 'PostCollision'\n        # rho_outlet = np.ones(doNothing.shape[0], dtype=self.precisionPolicy.compute_dtype)\n        # self.BCs.append(ZouHe(tuple(doNothing.T),\n        #                                          self.gridInfo,\n        #                                          self.precisionPolicy,\n        #                                          'pressure', rho_outlet))\n\n        inlet = self.boundingBoxIndices['left']\n        rho_inlet = np.ones((inlet.shape[0], 1), dtype=self.precisionPolicy.compute_dtype)\n        vel_inlet = np.zeros(inlet.shape, dtype=self.precisionPolicy.compute_dtype)\n\n        vel_inlet[:, 0] = prescribed_vel\n        self.BCs.append(EquilibriumBC(tuple(inlet.T), self.gridInfo, self.precisionPolicy, rho_inlet, vel_inlet))\n        # self.BCs.append(ZouHe(tuple(inlet.T),\n        #                                          self.gridInfo,\n        #                                          self.precisionPolicy,\n        #                                          'velocity', vel_inlet))\n\n\nprecision = 'f32/f32'\nlattice = LatticeD3Q27(precision)\n\nnx = 601\nny = 351\nnz = 251\n\nRe = 50000.0\nprescribed_vel = 0.05\nclength = nx - 1\n\nvisc = prescribed_vel * clength / Re\nomega = 1.0 / (3. * visc + 0.5)\n\nos.system('rm -rf ./*.vtk && rm -rf ./*.png')\n\nkwargs = {\n    'lattice': lattice,\n    'omega': omega,\n    'nx': nx,\n    'ny': ny,\n    'nz': nz,\n    'precision': precision,\n    'io_rate': 100,\n    'print_info_rate': 100,\n    'return_fpost': True  # Need to retain fpost-collision for computation of lift and drag\n}\nsim = Car(**kwargs)\nsim.run(200000)\n\n#NB if you get an error here, it is because cuda needs updateing\n# See https://jax.readthedocs.io/en/latest/installation.html#nvidia-gpu\n\n**** Simulation Parameters for Car ****\n            Parameter | Value\n--------------------------------------------------\n                Omega | 1.9928258270227182\n     Grid Points in X | 601\n     Grid Points in Y | 351\n     Grid Points in Z | 251\n       Dimensionality | 3\n     Precision Policy | f32/f32\n         Lattice Type | D3Q27\n      Checkpoint Rate | 0\n Checkpoint Directory | ./checkpoints\n  Downsampling Factor | 1\n      Print Info Rate | 100\n             I/O Rate | 100\n        Compute MLUPS | False\n   Restore Checkpoint | False\n              Backend | cpu\n    Number of Devices | 1\nVoxelizing mesh...\n\n\nValueError: string is not a file: stl-files/DrivAer-Notchback.stl",
    "crumbs": [
      "01_car_example.html"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "wind-simulation",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "wind-simulation"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "wind-simulation",
    "section": "Install",
    "text": "Install\npip install wind_simulation",
    "crumbs": [
      "wind-simulation"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "wind-simulation",
    "section": "How to use",
    "text": "How to use",
    "crumbs": [
      "wind-simulation"
    ]
  }
]